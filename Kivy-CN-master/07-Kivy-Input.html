<!DOCTYPE html>
<!-- saved from url=(0073)file:///C:/Users/Administrator/AppData/Local/Temp/MarkdownPadPreview.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>07-Kivy-Input</title>

<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<!--<base href="file:\\\D:\pythonProject\Kivy-CN-master\">--><base href=".">
</head>
<body>
<p>Title: Kivy Input management
Date: 2017-02-12
Category: Kivy
Tags: Python,Kivy</p>
<h1>Kivy中文编程指南：输入管理</h1>
<p><a href="https://kivy.org/docs/guide/inputs.html">英文原文</a></p>
<h2>译者前言</h2>
<p>这一章节比上一章节翻译的还差，最近睡眠不太好，术后恢复比较差，大家凑合看看，看不下去给指出来一下比较不好理解和绕的地方，以及错误的地方，我一定即时修改。</p>
<h2>输入体系</h2>
<p>Kivy能处理绝大多数的输入类型：鼠标，触摸屏，加速器，陀螺仪等等。并且针对以下平台能够处理多点触控的原生协议：Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B 以及 Android。（译者注：第一个TUIO应该是通用多点触控，第二个怀疑是WindowsMobile的，第三个是苹果的多点触控，第四个不知道是啥，最后一个是Android的。）</p>
<p>整体上输入体系的结构概括起来如下所示：</p>
<p>```HTML
Input providers -&gt; Motion event -&gt; Post processing -&gt; Dispatch to Window</p>
<p>输入源 -&gt; 动作事件 -&gt; 事后处理 -&gt; 分派到窗口
```</p>
<p>所有输入事件的类是<a href="https://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent" title="kivy.input.motionevent.MotionEvent"><code>MotionEvent</code></a>。这个类生成两种事件：</p>
<ul>
<li>
<p>Touch触控事件：包含位置信息，至少X和Y坐标位置的一种Motion动作事件。所有这种Touch事件都通过控件树进行分派。</p>
</li>
<li>
<p>Non-Touch非触控事件：其余的各种事件。例如加速度传感器就是一个持续的事件，不具有坐标位置。这一事件没有起止，一直在发生。这类的事件都不通过控件树来分派。</p>
</li>
</ul>
<p>Motion动作事件是由<a href="https://kivy.org/docs/api-kivy.input.providers.html#module-kivy.input.providers" title="kivy.input.providers"><code>InputProvider</code></a>生成的。 
InputProvider这个类就是负责读取输入事件，这些输入事件的来源可以是操作系统，网络或者其他的应用程序。如下这几个都是已有的输入源：</p>
<ul>
<li><a href="https://kivy.org/docs/api-kivy.input.providers.tuio.html#kivy.input.providers.tuio.TuioMotionEventProvider" title="kivy.input.providers.tuio.TuioMotionEventProvider"><code>TuioMotionEventProvider</code></a>：创建一个UDP服务端，侦听TUIO/OSC信息。</li>
<li><code>WM_MotionEventProvider</code>：使用Windows API来读取多点触控信息并发送给Kivy。</li>
<li><code>ProbeSysfsHardwareProbe</code>：在Linux中，遍历连接到计算机的所有硬件，并为找到的每个多点触摸设备附加一个多点触摸输入提供程序。</li>
<li>还有很多很多啦！</li>
</ul>
<p>当你写一个应用程序的时候，就不用再去重造一个输入源了。Kivy会自动检测可用的硬件。然而，如果你想要支持某些特殊定制的专门硬件，就可能得对Kivy的配置进行一下调整才行。</p>
<p>在新建的Motion动作事件被传递给用户之前，Kivy会先对输入进行处理。Kivy会对每一个动作事件进行分析来检查和纠正错误输入，也是保证能提供有意义的解释，比如：</p>
<ul>
<li>根据姿势和持续时间来检测双击或三次点击；</li>
<li>在硬件设备精度不佳的情况下提高事件精确度；</li>
<li>原生触摸硬件若在近似相同位置发送事件则降低生成事件数量。</li>
</ul>
<p>经过上面这些步骤之后，这个Motion动作事件就会被分派给对应的窗口。正如之前解释过的，并非所有事件都分派给整个控件树，程序窗口要对事件进行过滤筛选。对于一个给定的事件：</p>
<ul>
<li>
<p>如果仅仅是一个Motion动作事件，那它就会被分派给<a href="https://kivy.org/docs/api-kivy.core.window.html#kivy.core.window.WindowBase.on_motion" title="kivy.core.window.WindowBase.on_motion"><code>on_motion()</code></a>；</p>
</li>
<li>
<p>如果是一个Touch事件，这个触摸控件的坐标位置（x,y)（范围在0-1）会被调整到与窗口尺寸（宽高）相适应，然后对应发给下面这些方法：</p>
<ul>
<li><a href="https://kivy.org/docs/api-kivy.uix.widget.html#kivy.uix.widget.Widget.on_touch_down" title="kivy.uix.widget.Widget.on_touch_down"><code>on_touch_down()</code></a></li>
<li><a href="https://kivy.org/docs/api-kivy.uix.widget.html#kivy.uix.widget.Widget.on_touch_move" title="kivy.uix.widget.Widget.on_touch_move"><code>on_touch_move()</code></a></li>
<li><a href="https://kivy.org/docs/api-kivy.uix.widget.html#kivy.uix.widget.Widget.on_touch_up" title="kivy.uix.widget.Widget.on_touch_up"><code>on_touch_up()</code></a></li>
</ul>
</li>
</ul>
<h2>Motion动作事件的属性</h2>
<p>你用的硬件和输入源可能允许你能获取到更多信息。比如一个Touch触摸输入不仅有坐标位置（x,y），还可能有压力强度信息，触摸范围大小，加速度矢量等等。</p>
<p>在Motion动作事件中，有一个字符串作为profile属性，用于说明该事件内都有那些可用的效果。假如咱们有下面这样的一个<code>on_touch_move</code>方法：</p>
<p><code>Python
def on_touch_move(self, touch):
    print(touch.profile)
    return super(..., self).on_touch_move(touch)</code></p>
<p>在控制台的打印输出可能是：</p>
<p><code>Bash
['pos', 'angle']</code></p>
<h4>特别注意</h4>
<p>很多人可能会把这里Motion事件的Profile属性的名字与对应的Property属性弄混。一定要注意，可用Profile属性中存在<code>angle</code>，并不意味着Touch事件对象也必须有一个<code>angle</code>的Property属性。</p>
<p>对应profile属性<code>'pos'</code>，property属性中有位置信息<code>pos</code>，<code>x</code>,<code>y</code>。profile属性<code>angle</code>，property属性对应的是有角度<code>a</code>。刚刚我们就说了，对touchTouch事件来说，profile属性中按照惯例是必须有位置属性<code>pos</code>的，但不一定有角度属性<code>angle</code>。对角度属性<code>angle</code>是否存在，可以用下面的方法来检测一下：</p>
<p><code>Python
def on_touch_move(self, touch):
    print('The touch is at position', touch.pos)
    if 'angle' in touch.profile:
        print('The touch angle is', touch.a)</code></p>
<p>在<a href="https://kivy.org/docs/api-kivy.input.motionevent.html#module-kivy.input.motionevent" title="kivy.input.motionevent"><code>motionevent</code></a>文档中，可以找到所有可用profile属性的列表。</p>
<h2>Touch事件</h2>
<p>有一种特殊的<a href="https://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent" title="kivy.input.motionevent.MotionEvent"><code>MotionEvent</code>动作事件</a> ，这种事件的<a href="https://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent.is_touch" title="kivy.input.motionevent.MotionEvent.is_touch"><code>is_touch</code></a> 方法返回的是True，这就是Touch事件。</p>
<p>所有的Touch事件，都默认就有X和Y的坐标信息，与窗口的宽度和高度相匹配。换句话说就是所有的Touch事件都有<code>pos</code>这一profile属性。</p>
<h3>基本简介</h3>
<p>默认情况下，Touch事件会被分派给所有当前显示的控件。也就是说无论这个Touch是否发生在控件的物理范围内，控件都会收到它。</p>
<p>如果你接触过其他的GUI框架，可能觉得这特点挺违背直觉的。一般的GUI框架里面，都是把屏幕分割成多个几何区域，然后只在发生区域内的控件才会被分派到触摸或者鼠标事件。</p>
<p>这个设定对触摸输入的情景来说就过于严格了。因为用手指划，之间点戳，还有长时间按，都可能会有偏移导致落到 用户希望进行交互的控件外的情景。</p>
<p>为了提供最大的灵活性，Kivy会把事件分派给所有控件，然后让控件来自行决定如何应对这些事件。如果你只希望在某个控件内对Touch事件作出反应，只需要按照如下方法进行一下检测：</p>
<p><code>Python
def on_touch_down(self, touch):
    if self.collide_point(*touch.pos):
        # The touch has occurred inside the widgets area. Do stuff!
        pass</code></p>
<h3>坐标位置</h3>
<p>一旦你使用一个带有矩阵变换的控件，就一定要处理好Touch事件中的矩阵变换。例如<a href="https://kivy.org/docs/api-kivy.uix.scatter.html#kivy.uix.scatter.Scatter" title="kivy.uix.scatter.Scatter"><code>Scatter</code></a>这样的某些控件，自身会有矩阵变换，这就意味着Touch事件也必须用Scatter矩阵进行处理，这样才能正确地把Touch事件的位置分派给Scatter的子控件。</p>
<ul>
<li>从上层空间到本地空间获取坐标： <a href="https://kivy.org/docs/api-kivy.uix.widget.html#kivy.uix.widget.Widget.to_local" title="kivy.uix.widget.Widget.to_local"><code>to_local()</code></a></li>
<li>从本地空间到上层空间获取坐标：  <a href="https://kivy.org/docs/api-kivy.uix.widget.html#kivy.uix.widget.Widget.to_parent" title="kivy.uix.widget.Widget.to_parent"><code>to_parent()</code></a></li>
<li>从本地空间到窗口空间获取坐标：  <a href="https://kivy.org/docs/api-kivy.uix.widget.html#kivy.uix.widget.Widget.to_window" title="kivy.uix.widget.Widget.to_window"><code>to_window()</code></a></li>
<li>从窗口空间到本地空间获取坐标： <a href="https://kivy.org/docs/api-kivy.uix.widget.html#kivy.uix.widget.Widget.to_widget" title="kivy.uix.widget.Widget.to_widget"><code>to_widget()</code></a></li>
</ul>
<p>一定要使用上面方法当中的某一种来确保内容坐标系适配正确。然后下面这段代码里是Scatter的实现：</p>
<p>```Python
def on<em>touch</em>down(self, touch):
    # push the current coordinate, to be able to restore it later
	# 这里用push先把当前的坐标位置存留起来，以后就还可以恢复到这个坐标
    touch.push()</p>
<pre><code># transform the touch coordinate to local space
# 接下来就是把Touch的坐标转换成本地空间的坐标
touch.apply_transform_2d(self.to_local)

# dispatch the touch as usual to children
# the coordinate in the touch is now in local space
# 转换之后把这个Touch事件按照惯例分派给子控件
# Touch事件的坐标位置现在就是本地空间的了
ret = super(..., self).on_touch_down(touch)

# whatever the result, don't forget to pop your transformation
# after the call, so the coordinate will be back in parent space
#无论结果如何，一定记得把这个转换用pop弹出
# 之后，坐标就又恢复成上层空间的了
touch.pop()

# return the result (depending what you want.)
# 最后就是返回结果了
return ret
</code></pre>

<p>```</p>
<h3>Touch事件的形状</h3>
<p>If the touch has a shape, it will be reflected in the ‘shape’ property. Right now, only a <a href="https://kivy.org/docs/api-kivy.input.shape.html#kivy.input.shape.ShapeRect" title="kivy.input.shape.ShapeRect"><code>ShapeRect</code></a> can be exposed:</p>
<p>如果你的Touch事件有某个形状，这个信息会反映在<code>shape</code>这一property属性中。目前能用的就是一个 <a href="https://kivy.org/docs/api-kivy.input.shape.html#kivy.input.shape.ShapeRect" title="kivy.input.shape.ShapeRect"><code>ShapeRect</code></a>：</p>
<p><code>Python
from kivy.input.shape import ShapeRect
def on_touch_move(self, touch):
    if isinstance(touch.shape, ShapeRect):
        print('My touch have a rectangle shape of size',
            (touch.shape.width, touch.shape.height))
    # ...</code></p>
<h3>双击</h3>
<p>A double tap is the action of tapping twice within a time and a distance. It’s calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not:</p>
<p>双击是一种特定动作，在一小段时间和很短的一小段特定距离内敲击两下。双击的计算识别是通过一个双击后处理模块来实现的。可以用如下代码来检测当前的Touch是否是双击动作中的一下：</p>
<p><code>Python
def on_touch_down(self, touch):
    if touch.is_double_tap:
        print('Touch is a double tap !')
        print(' - interval is', touch.double_tap_time)
        print(' - distance between previous is', touch.double_tap_distance)
    # ...</code></p>
<h3>三次点击</h3>
<p>A triple tap is the action of tapping thrice within a time and a distance. It’s calculated by the tripletap post-processing module. You can test if the current touch is one of a triple tap or not:</p>
<p>三次点击和双击的概念类似，只不过是变成了点击三次。这个是通过一个三次点击后处理模块来计算识别的。可以用如下代码来检测当前的Touch是否是三次点击动作中的一下：</p>
<p><code>Python
def on_touch_down(self, touch):
    if touch.is_triple_tap:
        print('Touch is a triple tap !')
        print(' - interval is', touch.triple_tap_time)
        print(' - distance between previous is', touch.triple_tap_distance)
    # ...</code></p>
<h3>拖放事件</h3>
<p>父控件可能会从<code>on_touch_down</code>中分派Touch事件到子控件，而不从<code>on_touch_move</code>或<code>on_touch_up</code>分派。这可能发生在某些特定情况知悉啊，比如一个Touch处于父控件的边界之外，这样父控件就会决定不对子控件通知这个Touch。</p>
<p>But you might want to do something in <code>on_touch_up</code>. Say you started something in the <code>on_touch_down</code> event, like playing a sound, and you’d like to finish things on the <code>on_touch_up</code> event. Grabbing is what you need.</p>
<p>不过有可能你还是得处理一下<code>on_touch_up</code>。比方说，你开始是<code>on_touch_down</code>事件，假设是按下播放语音之类的，然后你希望当手指抬起的时候<code>on_touch_up</code>事件发生的时候就结束任务。这时候就需要有Grab拖放事件了。</p>
<p>When you grab a touch, you will always receive the move and up event. But there are some limitations to grabbing:</p>
<p>拖放一个Touch的时候，总会收到移动和抬起事件。但对拖放有如下的限制：</p>
<ul>
<li>
<p>至少会两次收到这个事件：一次是从父控件正常收到的事件，还有一次是从窗口获取的Grab拖放事件。</p>
</li>
<li>
<p>有可能你没有进行拖放，但还是会收到一个拖放Touch事件：这可能是因为在子控件处于拖放状态时，父控件发来了一个Touch事件。</p>
</li>
<li>
<p>在拖放状态下，Touch事件的坐标不会转换成控件空间的坐标，因为这个Touch事件是直接来自窗口的。所以要手动将坐标转换到本地空间。</p>
</li>
</ul>
<p>下面这段代码展示了对拖放的使用：</p>
<p>```Python
def on<em>touch</em>down(self, touch):
    if self.collide_point(*touch.pos):</p>
<pre><code>    # if the touch collides with our widget, let's grab it
    touch.grab(self)

    # and accept the touch.
    return True
</code></pre>

<p>def on<em>touch</em>up(self, touch):
    # here, you don't check if the touch collides or things like that.
    # you just need to check if it's a grabbed touch event
    if touch.grab_current is self:</p>
<pre><code>    # ok, the current touch is dispatched for us.
    # do something interesting here
    print('Hello world!')

    # don't forget to ungrab ourself, or you might have side effects
    touch.ungrab(self)

    # and accept the last up
    return True
</code></pre>

<p>```</p>
<h3>Touch事件管理</h3>
<p>想要了解更多Touch事件如何控制以及如何在控件之间传递，可以阅读一下<a href="https://kivy.org/docs/api-kivy.uix.widget.html#widget-event-bubbling">Widget touch event bubbling</a>这部分内容。</p>



<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
</body></html>